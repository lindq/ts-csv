import {excel, Quoting} from './dialect';

/** Describes a row of CSV writable values. */
export type Row = ReadonlyArray<unknown>;

/** Options for appending new data during write. */
interface AppendOpts {
  /**
   * If true, wraps empty fields in dialect.quoteChar, unless quoting is turned
   * off which throws an error.
   */
  quoteEmpty: boolean;
  /**
   * If true, writes data to buffer, otherwise scans over data to determine if
   * quoting is required for next pass character.
   */
  copyPhase: boolean;
}

/**
 * CSV writer.
 *
 * Writes arrays of data to CSV format. The flavor of CSV generated is governed
 * by an optional Dialect, with the default being the format generated by
 * Excel. Typical usage:
 *
 *   const data = [
 *     ['header 1', 'header 2'],
 *     ['foo', 'bar'],
 *     ['baz', 'qux'],
 *   ];
 *   const csv = [...writer(data)].join('');
 *   // csv === "header 1,header 2\r\nfoo,bar\r\nbaz,qux\r\n"
 */
export function* writer(rows: Row[], dialect = excel) {
  // The number of delimited fields generated during write.
  let numFields = 0;
  // If true, flags current field for quoting.
  let quoted = false;
  // Buffer to accumulate generated CSV for each row during write.
  let record = '';

  for (const row of rows) {
    reset();
    const quoteEmpty = row.length === 1;

    for (const field of row) {
      switch (dialect.quoting) {
        case Quoting.NON_NUMERIC:
          quoted = typeof field !== 'number';
          break;
        case Quoting.ALL:
          quoted = true;
          break;
        default:
          quoted = false;
          break;
      }
      const data = field == null ? '' : String(field);
      append(data, {quoteEmpty, copyPhase: false});
      append(data, {quoteEmpty, copyPhase: true});
      numFields++;
    }

    record += dialect.lineTerminator;
    yield record;
  }

  function append(data: string, opts: AppendOpts) {
    const addChar = (c: string) => {
      if (opts.copyPhase) {
        record += c;
      }
    };

    if (numFields > 0) {
      addChar(dialect.delimiter);
    }

    if (opts.copyPhase && quoted) {
      addChar(dialect.quoteChar);
    }

    const chars = data[Symbol.iterator]();
    for (const c of chars) {
      let wantEscape = false;

      if (c === dialect.delimiter || c === dialect.escapeChar ||
          c === dialect.quoteChar || dialect.lineTerminator.includes(c)) {
        if (dialect.quoting === Quoting.NONE) {
          wantEscape = true;
        } else {
          if (c === dialect.quoteChar) {
            if (dialect.doubleQuote) {
              addChar(dialect.quoteChar);
            } else {
              wantEscape = true;
            }
          }
          if (!wantEscape) {
            quoted = true;
          }
        }
        if (wantEscape) {
          if (!dialect.escapeChar) {
            throw new Error('need to escape, but no escapeChar set');
          }
          addChar(dialect.escapeChar);
        }
      }
      addChar(c);
    }

    if (!data && opts.quoteEmpty) {
      if (dialect.quoting === Quoting.NONE) {
        throw new Error('single empty field record must be quoted');
      } else {
        quoted = true;
      }
    }

    if (opts.copyPhase && quoted) {
      addChar(dialect.quoteChar);
    }
  }

  function reset() {
    record = '';
    quoted = false;
    numFields = 0;
  }
}

/** Describes a row of CSV writable key-value pairs. */
export type RecordRow = Record<string, unknown>;

/**
 * CSV key-value writer.
 *
 * Writes arrays of key-value pairs to CSV format. The flavor of CSV generated
 * is governed by an optional Dialect, with the default being the format
 * generated by Excel. An optional list of field names can be provided to ensure
 * the order of columns. Typical usage:
 *
 *   const data = [
 *     {'header 1': 'foo', 'header 2': 'bar'},
 *     {'header 1': 'baz', 'header 2': 'qux'},
 *   ];
 *   const csv = [...recordWriter(data)].join('');
 *   // csv === "header 1,header 2\r\nfoo,bar\r\nbaz,qux\r\n"
 */
export function*
    recordWriter(recordRows: RecordRow[], fields?: string[], dialect = excel) {
  const headers = fields || Object.keys(recordRows[0] || {});
  const rows: Row[] = [
    headers,
    ...recordRows.map(row => headers.map(field => row[field] || '')),
  ];
  for (const row of writer(rows, dialect)) {
    yield row;
  }
}
